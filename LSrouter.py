####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import heapq

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time # tần suất gửi trạng thái lk định kỳ
        self.last_time = 0
        # TODO
        self.links = {} # save local neigb
        self.seq = 0
        self.seq_nums = {} # lưu các seq mơi nhất nhận từ các r khác
        self.lsdb = {} # link state db gồm seq của r và các neighbor và cost
        self.forward_table = {} # bảng định tuyến
        
        #   add your own class fields and initialization code here
        #pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            # nếu là gói tin dữ liệu -> tra bảng định tuyến -> chuyển tiếp
            dst = packet.dst_addr
            if dst in self.forward_table:
                out_port = self.forward_table[dst]
                self.send(out_port, packet)
                
            # pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            # Nếu là gói tin định tuyến -> kiểm tra LSA
            kind, lsa = packet.payload
            if kind == 'LSA':
                self.process_lsa(port, lsa)
            # pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        self.links[endpoint] = (port, cost)
        self.seq += 1
        self.broadcast_lsa()
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        # Cập nhật bảng liên kết (self.links)
        # Tăng số thứ tự
        # Gửi LSA mới cho hàng xóm
        #pass

    def handle_remove_link(self, port): #lk bị mất
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        # Loại bỏ endpoint tương ứng khỏi self.links
        # Tăng sequence number
        # Gửi lại LSA
        remove_neighbor = None
        for neighbor, (p, _) in self.links.items():
            if p == port:
                remove_neighbor = neighbor
                break
            
        if remove_neighbor:
            del self.links[remove_neighbor]
            self.seq += 1
            self.broadcast_lsa()
        # pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            self.seq += 1
            self.broadcast_lsa()
            #   broadcast the link state of this router to all neighbors
            # gửi lại lsa của chính mình định kỳ
            # pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"

    def broadcast_lsa(self):
        links_info = {neighbor: cost for neighbor, (port, cost) in self.links.items()}
        #tạo bản sao thông tin liên kết hiênj taị
        
        lsa = {
            'origin' : self.addr,
            'seq' : self.seq,
            'links' : links_info
        }
        
        # Gửi cho tất cả hàng xóm
        for neighbor, (port, _) in self.links.items():
            self.send(port, ('LSA', lsa))
            
    def update_forwarding_table(self):
        # tính lại bảng fwd dùng dijkstra  
        # xây dt từ lsdb
        graph = {}
        
        #dùng các lsa đã nhận đc
        for node, neighbors in self.lsdb.items():
            graph[node] = neighbors.copy()
            
        # thêm chính router này vào
        graph[self.addr] = {neighbor: cost for neighbor, (port, cost) in self.links.items()}
        
        # Dijkstra
        dist = {self.addr: 0}
        prev = {}
        heap = [(0, self.addr)]
        
        while heap:
            cost, node = heapq.heappop(heap)
            for neighbor, edge_cost in graph.get(node, {}).items():
                new_cost = cost + edge_cost
                if neighbor not in dist or new_cost < dist[neighbor]:
                    dist[neighbor] = new_cost
                    prev[neighbor] = node
                    heapq.heappush(heap, (new_cost, neighbor))
                    
        # tạo forward_table từ dijkstra
        self.forward_table = {}
        for dest in dist: 
            if dest == self.addr:
                continue
            # tìm từ đích để next_hop
            next_hop = dest
            while prev.get(next_hop) != self.addr:
                next_hop = prev.get(next_hop)
                
            # từ next_hop tìm cổng
            if next_hop in self.links:
                port, _ = self.links[next_hop]
                self.forward_table[dest] = port