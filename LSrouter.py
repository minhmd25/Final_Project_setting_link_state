####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq
class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0 # theo dõi thời gian gửi LSA gần nhất 
        # TODO
        self.seq = 0 # Số thứ tự của LSA tăng khi LSA được tạo mới 
        self.neighbors = {} # danh sách các node lân cận gồm port nei và cost, dùng để lưu hàng xóm của các router theo cổng
        self.ports_to_neighbors = {} # biết cần gửi ls cho node từ cổng nào, cái này như ánh xạ ngược để biết gửi đến router bày phải qua cổng nào 
        self.lsdb = {} # topology của mạng như là graph để dùng cho ftb
        self.forwarding_table = {} # xây dựng bảng định tuyến
        #   add your own class fields and initialization code here
        # pass

    def handle_packet(self, port, packet): # Mục đích để xử lí 2 loại gói tin : loại dữ liệu (Traceroute) và định tuyến (LSA)
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute: # Với loại tin dữ liệu
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr # Lấy địa chỉ của gói tin 
            if dst in self.forwarding_table: # Nếu địa chỉ xuất hiện trong bảng định tuyến 
                out_port = self.forwarding_table[dst] # lấy cổng ra của địa chỉ gói tin 
                self.send(out_port, packet) # Gửi gói tin qua cổng ra vừa trích xuất được
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            lsa = json.loads(packet.content) # Lấy lsa
            name = lsa["name"]
            seq = lsa["seq"]
            links = lsa["links"]
            if name not in self.lsdb or seq > self.lsdb[name]["seq"]: # Nếu tên của gói tin chưa có trong lsdb hoặc số thứ tự mới lớn hơn cái cũ thì được cập nhật lại
                self.lsdb[name] = {
                    "seq": seq,
                    "links": links
                }
                self.run_dijkstra() # Cập nhật lại bảng định tuyến 
                
                for neighbor, p in self.ports_to_neighbors.items(): # gửi lsa đến tất cả hàng xóm, trừ cổng nhận đc gói tin 
                    if p != port:
                        self.send(p, packet)
            

    def handle_new_link(self, port, endpoint, cost): # Cập nhật khi router cập nhật hàng xóm mới 
        """Handle new link."""
        # TODO
        self.neighbors[port] = (endpoint, cost) # port -> (neighbor, cost) . Thêm hàng xóm 
        self.ports_to_neighbors[endpoint] = port # neighbor -> port. Cập nhật ánh xạ ngược 
        self.lsdb[self.addr] = {                 # Cập nhật lại LSDB
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        self.seq += 1 # tăng seq để gửi đi
        self.flood_own_lsa() # gửi lsa cho các node lân cận và bản thân
        self.run_dijkstra() # Mục đích cập nhật forwarding Table 
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        

    def handle_remove_link(self, port):
        """Handle removed link."""
        # Xóa liên kết khỏi neighbors và ports_to_neighbors
        if port in self.neighbors:
            endpoint, _ = self.neighbors[port]
            del self.neighbors[port]
            if endpoint in self.ports_to_neighbors:
                del self.ports_to_neighbors[endpoint]
        
        # Cập nhật LSDB của router này
        self.lsdb[self.addr] = {
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        self.seq += 1  # Tăng sequence number để đánh dấu LSA mới
        
        # Gửi LSA mới đến các neighbor
        self.flood_own_lsa()
        
        # Tính lại bảng định tuyến
        self.run_dijkstra()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # Gửi lại LSA của router này đến các neighbor
            self.flood_own_lsa()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
    
    def flood_own_lsa(self):
        lsa = {
            "name": self.addr,
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        packet = Packet(Packet.ROUTING, self.addr, None, json.dumps(lsa))
        for neighbor, port in self.ports_to_neighbors.items():
            self.send(port, packet)
        

    def run_dijkstra(self):
        graph = {}  # tên router → các hàng xóm và cost
        for router, entry in self.lsdb.items():
            graph[router] = entry["links"]

        dist = {self.addr: 0}
        prev = {}
        visited = set()
        heap = [(0, self.addr)]

        while heap:
            cost_u, u = heapq.heappop(heap)
            if u in visited:
                continue
            visited.add(u)

            for v, cost_uv in graph.get(u, {}).items():
                if v not in dist or cost_u + cost_uv < dist[v]:
                    dist[v] = cost_u + cost_uv
                    prev[v] = u
                    heapq.heappush(heap, (dist[v], v))

        self.forwarding_table = {}

        for dest in dist:
            if dest == self.addr:
                continue
            # truy ngược đường đi để tìm next hop
            next_hop = dest
            while prev.get(next_hop) != self.addr:
                next_hop = prev.get(next_hop, next_hop)
            # ánh xạ next_hop → port
            if next_hop in self.ports_to_neighbors:
                port = self.ports_to_neighbors[next_hop]
                self.forwarding_table[dest] = port